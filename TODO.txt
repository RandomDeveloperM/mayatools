Fluids
--------------

- may need to advect the two frames and then do a linear blend on them
  - see Wikipedia for the hairy math http://en.wikipedia.org/wiki/Advection
  - google for "fluid advect c++"
  - two step? http://code.google.com/p/fluidic/source/browse/trunk/Resources/Advect.cg?r=15
  - do this at the very end

- How is velocity laid out?
    It is on the surfaces bettween voxels.

    Test to set velocities: 
        for x in range(3):
            for y in range(5):
                for z in range(7):
                    cmds.setFluidAttr(at='density', xi=x, yi=y, zi=z, fv=(x + y + z))
                    cmds.setFluidAttr(at='velocity', xi=x, yi=y, zi=z, vv=(x + 1, y + 1, z + 1))

    Duncan says:
        Velocity is defined at voxel boundaries, not the centers (it takes a little thinking to appreciate this fully). Thus for a 10x10x10 grid the velocityX grid will be (11,10,10), the velocityY(10,11,10) and the velocityZ(10,10,11).

    The API docs also clarify quite well:
        http://download.autodesk.com/us/maya/2011help/API/class_m_fn_fluid.html#0ae37ed733007e9eb82dbe2231335293

    Looking at the raw data set via cmds.setFluidAttr(..., lowerFace=True), the X values go (0, 1, 2, 2), the Y (0, 1, 2, 3, 4, 4),
    and the Z do the same. They also iterate in the same Z,Y,X order that the density does.

- Tests:
    densities:
        - set density to X/Y/Z coordinate + 1
    densities/combined.mc
        - set density to (x * 100 + y * 10 + z)
    fluid-velocities-1:
        - set density to x/y/z coordinate + 1
        - set velocity to (1, 0, 0) for X
        - does not use lowerFace for velocity
        - combined -> cmds.setFluidAttr(at='velocity', xi=x, yi=y, zi=z, vv=(x, y, z), lowerFace=True)

- My tests indicate that the velocities are in local coordinates (even after
  rotating and scaling, and that my velocity lookup code is good).
- Do velocities need to be scaled by the "rate scale"?



General
-------

- context.parent
- context.progress as p
    Wrap progressWindow, or the main progress bar

- CommandPort.call(..., stdio=True, main_thread=True)
    -> we want to run our nose in a secondary thread that keeps calling
       out to the main thread but then holding back

    @maya_test
    def test_only_needs_standalone():
        pass

    @maya_test(version=2011)
    
    @maya_test(gui=True):
    def test_in_main_gui_thread(self):

        # this is the main thread
        # if this returns a generator then it is assumed to be a trampoline

        res = yield waitfor(2), functools.partial(qpath, root, 'query')

        # yield will return our results, or throw a TimeoutError

        res = yield waitfor(2)

    raise SkipTest if it isn't in maya


